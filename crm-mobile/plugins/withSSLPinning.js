/**
 * Expo Config Plugin for SSL Certificate Pinning
 *
 * This plugin configures native SSL pinning for both Android and iOS.
 *
 * USAGE:
 * 1. Add to app.json/app.config.js plugins array
 * 2. Configure your certificate hashes in the plugin options
 * 3. Run `expo prebuild` to generate native code
 * 4. Build with `expo run:android` or `expo run:ios`
 *
 * NOTE: SSL Pinning does NOT work in Expo Go. You must use a development build.
 */

const {
  withAndroidManifest,
  withInfoPlist,
  withDangerousMod,
} = require("expo/config-plugins");
const fs = require("fs");
const path = require("path");

/**
 * Configure Android Network Security Config for SSL Pinning
 */
function withAndroidSSLPinning(config, props) {
  // First, add the network security config reference to AndroidManifest.xml
  config = withAndroidManifest(config, (config) => {
    const mainApplication = config.modResults.manifest.application[0];

    // Add network security config attribute
    mainApplication.$["android:networkSecurityConfig"] =
      "@xml/network_security_config";

    return config;
  });

  // Then, create the network_security_config.xml file
  config = withDangerousMod(config, [
    "android",
    async (config) => {
      const xmlDir = path.join(
        config.modRequest.platformProjectRoot,
        "app",
        "src",
        "main",
        "res",
        "xml"
      );

      // Create xml directory if it doesn't exist
      if (!fs.existsSync(xmlDir)) {
        fs.mkdirSync(xmlDir, { recursive: true });
      }

      // Generate pin-set entries
      const pinSets = (props.pins || [])
        .map((pin) => {
          const pins = pin.publicKeyHashes
            .map((hash) => {
              // Remove "sha256/" prefix if present
              const cleanHash = hash.replace("sha256/", "");
              return `            <pin digest="SHA-256">${cleanHash}</pin>`;
            })
            .join("\n");

          return `
        <domain-config cleartextTrafficPermitted="false">
            <domain includeSubdomains="${pin.includeSubdomains !== false}">${pin.hostname}</domain>
            <pin-set expiration="${props.pinExpiration || "2026-12-31"}">
${pins}
            </pin-set>
        </domain-config>`;
        })
        .join("\n");

      // Create network_security_config.xml content
      const networkSecurityConfig = `<?xml version="1.0" encoding="utf-8"?>
<!--
    Network Security Configuration for SSL Pinning
    Generated by withSSLPinning Expo plugin

    SECURITY: This configuration enforces certificate pinning for the specified domains.
    Connections will fail if the server's certificate doesn't match the pinned hashes.

    WARNING: If certificates are rotated without updating this config, the app will
    fail to connect. Always include backup pins and plan for certificate rotation.
-->
<network-security-config>
    <!-- Base configuration: require HTTPS for all connections in release builds -->
    <base-config cleartextTrafficPermitted="${props.allowCleartext === true}">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
${pinSets}
    <!-- Debug overrides: allow user-installed CA certificates in debug builds -->
    <debug-overrides>
        <trust-anchors>
            <certificates src="user" />
        </trust-anchors>
    </debug-overrides>
</network-security-config>
`;

      const configPath = path.join(xmlDir, "network_security_config.xml");
      fs.writeFileSync(configPath, networkSecurityConfig);

      console.log(
        `[withSSLPinning] Created Android network_security_config.xml with ${
          props.pins?.length || 0
        } pinned domains`
      );

      return config;
    },
  ]);

  return config;
}

/**
 * Configure iOS App Transport Security for SSL Pinning
 *
 * Note: iOS doesn't have built-in certificate pinning like Android.
 * For full pinning support on iOS, consider using TrustKit library.
 * This config sets up ATS for HTTPS enforcement.
 */
function withIOSSSLPinning(config, props) {
  return withInfoPlist(config, (config) => {
    // Configure App Transport Security
    config.modResults.NSAppTransportSecurity = {
      // Require HTTPS for all connections (no cleartext HTTP)
      NSAllowsArbitraryLoads: false,

      // Exception domains (if needed for development)
      NSExceptionDomains: {
        // Allow localhost for development
        localhost: {
          NSExceptionAllowsInsecureHTTPLoads: true,
          NSIncludesSubdomains: true,
        },
      },
    };

    // Add TrustKit configuration if pins are provided
    // TrustKit is a popular iOS SSL pinning library
    if (props.pins && props.pins.length > 0) {
      const trustKitConfig = {
        TSKSwizzleNetworkDelegates: false,
        TSKPinnedDomains: {},
      };

      props.pins.forEach((pin) => {
        trustKitConfig.TSKPinnedDomains[pin.hostname] = {
          TSKIncludeSubdomains: pin.includeSubdomains !== false,
          TSKEnforcePinning: true,
          TSKPublicKeyHashes: pin.publicKeyHashes.map((hash) =>
            hash.replace("sha256/", "")
          ),
        };
      });

      config.modResults.TSKConfiguration = trustKitConfig;
    }

    console.log(
      `[withSSLPinning] Configured iOS App Transport Security with ${
        props.pins?.length || 0
      } pinned domains`
    );

    return config;
  });
}

/**
 * Main plugin function
 */
function withSSLPinning(config, props = {}) {
  // Validate props
  if (!props.pins || props.pins.length === 0) {
    console.warn(
      "[withSSLPinning] No certificate pins configured. SSL pinning will not be enforced."
    );
  }

  // Apply Android configuration
  config = withAndroidSSLPinning(config, props);

  // Apply iOS configuration
  config = withIOSSSLPinning(config, props);

  return config;
}

module.exports = withSSLPinning;
